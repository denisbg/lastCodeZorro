{
    "sourceFile": "e.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 15,
            "patches": [
                {
                    "date": 1709669310026,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1709669816166,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -139,8 +139,8 @@\n     for _ in range(lines_removed):\r\n         new_board.insert(0, [0 for _ in range(SCREEN_WIDTH // BLOCK_SIZE)])\r\n     return new_board, lines_removed\r\n \r\n-if _name_ == '_main_':\r\n+if __name__ == '_main_':\r\n     screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\r\n     clock = pygame.time.Clock()\r\n     main()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1709670003576,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,146 +1,134 @@\n import pygame\r\n import random\r\n-import numpy as np\r\n \r\n-pygame.init()\r\n-\r\n-# Paramètres de base\r\n-SCREEN_WIDTH = 300\r\n+# Définition des constantes\r\n+SCREEN_WIDTH = 800\r\n SCREEN_HEIGHT = 600\r\n BLOCK_SIZE = 30\r\n-FPS = 30\r\n-COLOR_CHANGE_FREQUENCY = 1000  # changer de couleur toutes les 1000 frames\r\n+ROWS = 20\r\n+COLS = 10\r\n+WHITE = (255, 255, 255)\r\n+BLACK = (0, 0, 0)\r\n \r\n-# Couleurs de l'arc-en-ciel\r\n-RAINBOW_COLORS = [\r\n-    (255, 0, 0),     # Rouge\r\n-    (255, 165, 0),   # Orange\r\n-    (255, 255, 0),   # Jaune\r\n-    (0, 255, 0),     # Vert\r\n-    (0, 0, 255),     # Bleu\r\n-    (75, 0, 130),    # Indigo\r\n-    (148, 0, 211)    # Violet\r\n-]\r\n+# Formes des blocs\r\n+SHAPES = [\r\n+    [[1, 1, 1],\r\n+     [0, 1, 0]],\r\n \r\n-# Définition des formes de Tetris avec leurs couleurs correspondantes\r\n-tetris_shapes = [\r\n-    [[1, 1, 1],\r\n-     [0, 1, 0]],  # L\r\n     [[0, 2, 2],\r\n-     [2, 2, 0]],  # S\r\n-    [[3, 3, 0],\r\n-     [0, 3, 3]],  # Z\r\n-    [[4, 0, 0],\r\n-     [4, 4, 4]],  # T\r\n-    [[0, 0, 5],\r\n-     [5, 5, 5]],  # J\r\n-    [[6, 6, 6, 6]],  # I\r\n-    [[7, 7],\r\n-     [7, 7]]  # O\r\n-]\r\n+     [2, 2, 0]],\r\n \r\n-# Couleurs correspondantes aux formes de Tetris\r\n-tetris_colors = [\r\n-    (0, 0, 0),   # Noir\r\n-    (255, 0, 0), # Rouge\r\n-    (0, 255, 0), # Vert\r\n-    (0, 0, 255), # Bleu\r\n-    (255, 255, 0), # Jaune\r\n-    (255, 165, 0), # Orange\r\n-    (75, 0, 130),  # Indigo\r\n-    (148, 0, 211)  # Violet\r\n+    [[3, 3],\r\n+     [3, 3]],\r\n+\r\n+    [[4, 4, 4, 4]],\r\n+\r\n+    [[0, 5, 0],\r\n+     [5, 5, 5]],\r\n+\r\n+    [[6, 0],\r\n+     [6, 0],\r\n+     [6, 6]],\r\n+\r\n+    [[0, 7],\r\n+     [0, 7],\r\n+     [7, 7]]\r\n ]\r\n \r\n-def draw_matrix(matrix, offset):\r\n-    for y, row in enumerate(matrix):\r\n-        for x, val in enumerate(row):\r\n-            if val:\r\n-                pygame.draw.rect(screen, tetris_colors[val], pygame.Rect((offset[0] + x) * BLOCK_SIZE, (offset[1] + y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), 0)\r\n \r\n-def new_piece():\r\n-    shape = random.choice(tetris_shapes)\r\n-    piece = {}\r\n-    piece['shape'] = shape\r\n-    piece['color'] = tetris_colors[tetris_shapes.index(shape)]\r\n-    piece['x'] = SCREEN_WIDTH // 2 - len(shape[0]) // 2\r\n-    piece['y'] = 0\r\n-    return piece\r\n+class Block:\r\n+    def __init__(self, shape):\r\n+        self.shape = shape\r\n+        self.color = (random.randint(50, 255), random.randint(50, 255), random.randint(50, 255))\r\n+        self.x = COLS // 2 - len(shape[0]) // 2\r\n+        self.y = 0\r\n \r\n-def check_collision(board, piece, offset):\r\n-    off_x, off_y = offset\r\n-    for y, row in enumerate(piece):\r\n-        for x, val in enumerate(row):\r\n-            if val:\r\n-                if y + piece['y'] + off_y >= len(board) or \\\r\n-                   x + piece['x'] + off_x < 0 or \\\r\n-                   x + piece['x'] + off_x >= len(board[0]) or \\\r\n-                   board[y + piece['y'] + off_y][x + piece['x'] + off_x]:\r\n-                    return True\r\n-    return False\r\n+    def move_down(self):\r\n+        self.y += 1\r\n \r\n-def rotate(piece):\r\n-    rotated_shape = np.rot90(piece['shape'])\r\n-    return rotated_shape.tolist()\r\n+    def move_left(self):\r\n+        self.x -= 1\r\n \r\n-def remove_row(board, row):\r\n-    del board[row]\r\n-    return [[0 for _ in range(SCREEN_WIDTH // BLOCK_SIZE)]] + board, 1\r\n+    def move_right(self):\r\n+        self.x += 1\r\n \r\n-def join_matrixes(board, piece, offset):\r\n-    off_x, off_y = offset\r\n-    for y, row in enumerate(piece):\r\n-        for x, val in enumerate(row):\r\n-            if val:\r\n-                board[y + piece['y'] + off_y][x + piece['x'] + off_x] = val\r\n-    return board\r\n+    def rotate(self):\r\n+        self.shape = [[self.shape[y][x] for y in range(len(self.shape))] for x in range(len(self.shape[0]))[::-1]]\r\n \r\n+    def get_blocks_positions(self):\r\n+        positions = []\r\n+        for y in range(len(self.shape)):\r\n+            for x in range(len(self.shape[y])):\r\n+                if self.shape[y][x] != 0:\r\n+                    positions.append((self.x + x, self.y + y))\r\n+        return positions\r\n+\r\n+\r\n+def draw_board(screen, board):\r\n\\ No newline at end of file\n+    for y in range(ROWS):\r\n+        for x in range(COLS):\r\n+            if board[y][x] != 0:\r\n+                pygame.draw.rect(screen, WHITE, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n+                pygame.draw.rect(screen, BLACK, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), 1)\r\n+\r\n+\r\n def main():\r\n-    board = [[0 for _ in range(SCREEN_WIDTH // BLOCK_SIZE)] for _ in range(SCREEN_HEIGHT // BLOCK_SIZE)]\r\n+    pygame.init()\r\n+    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\r\n+    pygame.display.set_caption(\"Tetris\")\r\n+    clock = pygame.time.Clock()\r\n \r\n-    piece = new_piece()\r\n-    game_over = False\r\n-    score = 0\r\n-    frame_count = 0\r\n-    current_color_index = 0\r\n+    board = [[0] * COLS for _ in range(ROWS)]\r\n \r\n-    # Initialisation de l'écran avec une couleur de l'arc-en-ciel\r\n-    screen.fill(RAINBOW_COLORS[current_color_index])\r\n+    current_block = Block(random.choice(SHAPES))\r\n+    next_block = Block(random.choice(SHAPES))\r\n \r\n-    while not game_over:\r\n-        # Mise à jour de l'affichage de l'écran\r\n-        pygame.display.update()\r\n+    while True:\r\n+        screen.fill(BLACK)\r\n \r\n-        # Gestion des événements\r\n+        # Contrôles\r\n         for event in pygame.event.get():\r\n             if event.type == pygame.QUIT:\r\n-                game_over = True\r\n+                pygame.quit()\r\n+                return\r\n+            elif event.type == pygame.KEYDOWN:\r\n+                if event.key == pygame.K_LEFT:\r\n+                    current_block.move_left()\r\n+                    if any((x < 0 or board[y][x] != 0) for x, y in current_block.get_blocks_positions()):\r\n+                        current_block.move_right()\r\n+                elif event.key == pygame.K_RIGHT:\r\n+                    current_block.move_right()\r\n+                    if any((x >= COLS or board[y][x] != 0) for x, y in current_block.get_blocks_positions()):\r\n+                        current_block.move_left()\r\n+                elif event.key == pygame.K_DOWN:\r\n+                    current_block.move_down()\r\n+                    if any((y >= ROWS or board[y][x] != 0) for x, y in current_block.get_blocks_positions()):\r\n+                        current_block.move_up()\r\n+                elif event.key == pygame.K_SPACE:\r\n+                    current_block.rotate()\r\n+                    if any((x < 0 or x >= COLS or y >= ROWS or board[y][x] != 0) for x, y in\r\n+                           current_block.get_blocks_positions()):\r\n+                        current_block.rotate()\r\n \r\n-        # Logique du jeu ici...\r\n+        # Déplacer le bloc vers le bas\r\n+        current_block.move_down()\r\n+        if any((y >= ROWS or board[y][x] != 0) for x, y in current_block.get_blocks_positions()):\r\n+            current_block.move_up()\r\n+            for x, y in current_block.get_blocks_positions():\r\n+                board[y][x] = current_block.color\r\n+            current_block = next_block\r\n+            next_block = Block(random.choice(SHAPES))\r\n \r\n-        # Incrémenter le compteur de frames\r\n-        frame_count += 1\r\n+        # Dessiner le tableau\r\n+        draw_board(screen, board)\r\n \r\n-        # Changer la couleur de l'arrière-plan toutes les COLOR_CHANGE_FREQUENCY frames\r\n-        if frame_count >= COLOR_CHANGE_FREQUENCY:\r\n-            frame_count = 0\r\n-            current_color_index = (current_color_index + 1) % len(RAINBOW_COLORS)\r\n-            screen.fill(RAINBOW_COLORS[current_color_index])\r\n+        # Dessiner le bloc courant\r\n+        for x, y in current_block.get_blocks_positions():\r\n+            pygame.draw.rect(screen, current_block.color, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n \r\n-    pygame.quit()\r\n+        pygame.display.flip()\r\n+        clock.tick(5)\r\n \r\n-def remove_completed_lines(board):\r\n-    lines_removed = 0\r\n-    new_board = []\r\n-    for row in range(len(board)):\r\n-        if not all(board[row]):\r\n-            new_board.append(board[row])\r\n-        else:\r\n-            lines_removed += 1\r\n-    for _ in range(lines_removed):\r\n-        new_board.insert(0, [0 for _ in range(SCREEN_WIDTH // BLOCK_SIZE)])\r\n-    return new_board, lines_removed\r\n \r\n-if __name__ == '_main_':\r\n-    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\r\n-    clock = pygame.time.Clock()\r\n-    main()\n+if __name__ == \"__main__\":\r\n+    main()\r\n"
                },
                {
                    "date": 1709670056287,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,134 +1,146 @@\n import pygame\r\n import random\r\n+import numpy as np\r\n \r\n-# Définition des constantes\r\n-SCREEN_WIDTH = 800\r\n+pygame.init()\r\n+\r\n+# Paramètres de base\r\n+SCREEN_WIDTH = 300\r\n SCREEN_HEIGHT = 600\r\n BLOCK_SIZE = 30\r\n-ROWS = 20\r\n-COLS = 10\r\n-WHITE = (255, 255, 255)\r\n-BLACK = (0, 0, 0)\r\n+FPS = 30\r\n+COLOR_CHANGE_FREQUENCY = 1000  # changer de couleur toutes les 1000 frames\r\n \r\n-# Formes des blocs\r\n-SHAPES = [\r\n+# Couleurs de l'arc-en-ciel\r\n+RAINBOW_COLORS = [\r\n+    (255, 0, 0),     # Rouge\r\n+    (255, 165, 0),   # Orange\r\n+    (255, 255, 0),   # Jaune\r\n+    (0, 255, 0),     # Vert\r\n+    (0, 0, 255),     # Bleu\r\n+    (75, 0, 130),    # Indigo\r\n+    (148, 0, 211)    # Violet\r\n+]\r\n+\r\n+# Définition des formes de Tetris avec leurs couleurs correspondantes\r\n+tetris_shapes = [\r\n     [[1, 1, 1],\r\n-     [0, 1, 0]],\r\n-\r\n+     [0, 1, 0]],  # L\r\n     [[0, 2, 2],\r\n-     [2, 2, 0]],\r\n+     [2, 2, 0]],  # S\r\n+    [[3, 3, 0],\r\n+     [0, 3, 3]],  # Z\r\n+    [[4, 0, 0],\r\n+     [4, 4, 4]],  # T\r\n+    [[0, 0, 5],\r\n+     [5, 5, 5]],  # J\r\n+    [[6, 6, 6, 6]],  # I\r\n+    [[7, 7],\r\n+     [7, 7]]  # O\r\n+]\r\n \r\n-    [[3, 3],\r\n-     [3, 3]],\r\n-\r\n-    [[4, 4, 4, 4]],\r\n-\r\n-    [[0, 5, 0],\r\n-     [5, 5, 5]],\r\n-\r\n-    [[6, 0],\r\n-     [6, 0],\r\n-     [6, 6]],\r\n-\r\n-    [[0, 7],\r\n-     [0, 7],\r\n-     [7, 7]]\r\n+# Couleurs correspondantes aux formes de Tetris\r\n+tetris_colors = [\r\n+    (0, 0, 0),   # Noir\r\n+    (255, 0, 0), # Rouge\r\n+    (0, 255, 0), # Vert\r\n+    (0, 0, 255), # Bleu\r\n+    (255, 255, 0), # Jaune\r\n+    (255, 165, 0), # Orange\r\n+    (75, 0, 130),  # Indigo\r\n+    (148, 0, 211)  # Violet\r\n ]\r\n \r\n+def draw_matrix(matrix, offset):\r\n+    for y, row in enumerate(matrix):\r\n+        for x, val in enumerate(row):\r\n+            if val:\r\n+                pygame.draw.rect(screen, tetris_colors[val], pygame.Rect((offset[0] + x) * BLOCK_SIZE, (offset[1] + y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), 0)\r\n \r\n-class Block:\r\n-    def __init__(self, shape):\r\n-        self.shape = shape\r\n-        self.color = (random.randint(50, 255), random.randint(50, 255), random.randint(50, 255))\r\n-        self.x = COLS // 2 - len(shape[0]) // 2\r\n-        self.y = 0\r\n+def new_piece():\r\n+    shape = random.choice(tetris_shapes)\r\n+    piece = {}\r\n+    piece['shape'] = shape\r\n+    piece['color'] = tetris_colors[tetris_shapes.index(shape)]\r\n+    piece['x'] = SCREEN_WIDTH // 2 - len(shape[0]) // 2\r\n+    piece['y'] = 0\r\n+    return piece\r\n \r\n-    def move_down(self):\r\n-        self.y += 1\r\n+def check_collision(board, piece, offset):\r\n+    off_x, off_y = offset\r\n+    for y, row in enumerate(piece):\r\n+        for x, val in enumerate(row):\r\n+            if val:\r\n+                if y + piece['y'] + off_y >= len(board) or \\\r\n+                   x + piece['x'] + off_x < 0 or \\\r\n+                   x + piece['x'] + off_x >= len(board[0]) or \\\r\n+                   board[y + piece['y'] + off_y][x + piece['x'] + off_x]:\r\n+                    return True\r\n+    return False\r\n \r\n-    def move_left(self):\r\n-        self.x -= 1\r\n+def rotate(piece):\r\n+    rotated_shape = np.rot90(piece['shape'])\r\n+    return rotated_shape.tolist()\r\n \r\n-    def move_right(self):\r\n-        self.x += 1\r\n+def remove_row(board, row):\r\n+    del board[row]\r\n+    return [[0 for _ in range(SCREEN_WIDTH // BLOCK_SIZE)]] + board, 1\r\n \r\n-    def rotate(self):\r\n-        self.shape = [[self.shape[y][x] for y in range(len(self.shape))] for x in range(len(self.shape[0]))[::-1]]\r\n+def join_matrixes(board, piece, offset):\r\n+    off_x, off_y = offset\r\n+    for y, row in enumerate(piece):\r\n+        for x, val in enumerate(row):\r\n+            if val:\r\n+                board[y + piece['y'] + off_y][x + piece['x'] + off_x] = val\r\n+    return board\r\n \r\n-    def get_blocks_positions(self):\r\n-        positions = []\r\n-        for y in range(len(self.shape)):\r\n-            for x in range(len(self.shape[y])):\r\n-                if self.shape[y][x] != 0:\r\n-                    positions.append((self.x + x, self.y + y))\r\n-        return positions\r\n-\r\n-\r\n-def draw_board(screen, board):\r\n-    for y in range(ROWS):\r\n-        for x in range(COLS):\r\n-            if board[y][x] != 0:\r\n-                pygame.draw.rect(screen, WHITE, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n-                pygame.draw.rect(screen, BLACK, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), 1)\r\n-\r\n-\r\n def main():\r\n-    pygame.init()\r\n-    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\r\n-    pygame.display.set_caption(\"Tetris\")\r\n-    clock = pygame.time.Clock()\r\n+    board = [[0 for _ in range(SCREEN_WIDTH // BLOCK_SIZE)] for _ in range(SCREEN_HEIGHT // BLOCK_SIZE)]\r\n \r\n-    board = [[0] * COLS for _ in range(ROWS)]\r\n+    piece = new_piece()\r\n+    game_over = False\r\n+    score = 0\r\n+    frame_count = 0\r\n+    current_color_index = 0\r\n \r\n-    current_block = Block(random.choice(SHAPES))\r\n-    next_block = Block(random.choice(SHAPES))\r\n+    # Initialisation de l'écran avec une couleur de l'arc-en-ciel\r\n+    screen.fill(RAINBOW_COLORS[current_color_index])\r\n \r\n-    while True:\r\n-        screen.fill(BLACK)\r\n+    while not game_over:\r\n+        # Mise à jour de l'affichage de l'écran\r\n+        pygame.display.update()\r\n \r\n-        # Contrôles\r\n+        # Gestion des événements\r\n         for event in pygame.event.get():\r\n             if event.type == pygame.QUIT:\r\n-                pygame.quit()\r\n-                return\r\n-            elif event.type == pygame.KEYDOWN:\r\n-                if event.key == pygame.K_LEFT:\r\n-                    current_block.move_left()\r\n-                    if any((x < 0 or board[y][x] != 0) for x, y in current_block.get_blocks_positions()):\r\n-                        current_block.move_right()\r\n-                elif event.key == pygame.K_RIGHT:\r\n-                    current_block.move_right()\r\n-                    if any((x >= COLS or board[y][x] != 0) for x, y in current_block.get_blocks_positions()):\r\n-                        current_block.move_left()\r\n-                elif event.key == pygame.K_DOWN:\r\n-                    current_block.move_down()\r\n-                    if any((y >= ROWS or board[y][x] != 0) for x, y in current_block.get_blocks_positions()):\r\n-                        current_block.move_up()\r\n-                elif event.key == pygame.K_SPACE:\r\n-                    current_block.rotate()\r\n-                    if any((x < 0 or x >= COLS or y >= ROWS or board[y][x] != 0) for x, y in\r\n-                           current_block.get_blocks_positions()):\r\n-                        current_block.rotate()\r\n+                game_over = True\r\n \r\n-        # Déplacer le bloc vers le bas\r\n-        current_block.move_down()\r\n-        if any((y >= ROWS or board[y][x] != 0) for x, y in current_block.get_blocks_positions()):\r\n-            current_block.move_up()\r\n-            for x, y in current_block.get_blocks_positions():\r\n-                board[y][x] = current_block.color\r\n-            current_block = next_block\r\n-            next_block = Block(random.choice(SHAPES))\r\n+        # Logique du jeu ici...\r\n \r\n-        # Dessiner le tableau\r\n-        draw_board(screen, board)\r\n+        # Incrémenter le compteur de frames\r\n+        frame_count += 1\r\n \r\n-        # Dessiner le bloc courant\r\n-        for x, y in current_block.get_blocks_positions():\r\n-            pygame.draw.rect(screen, current_block.color, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n+        # Changer la couleur de l'arrière-plan toutes les COLOR_CHANGE_FREQUENCY frames\r\n+        if frame_count >= COLOR_CHANGE_FREQUENCY:\r\n+            frame_count = 0\r\n+            current_color_index = (current_color_index + 1) % len(RAINBOW_COLORS)\r\n+            screen.fill(RAINBOW_COLORS[current_color_index])\r\n \r\n-        pygame.display.flip()\r\n-        clock.tick(5)\r\n+    pygame.quit()\r\n \r\n+def remove_completed_lines(board):\r\n+    lines_removed = 0\r\n+    new_board = []\r\n+    for row in range(len(board)):\r\n+        if not all(board[row]):\r\n+            new_board.append(board[row])\r\n+        else:\r\n+            lines_removed += 1\r\n+    for _ in range(lines_removed):\r\n+        new_board.insert(0, [0 for _ in range(SCREEN_WIDTH // BLOCK_SIZE)])\r\n+    return new_board, lines_removed\r\n \r\n-if __name__ == \"__main__\":\r\n+if _name_ == '_main_':\r\n+    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\r\n+    clock = pygame.time.Clock()\r\n     main()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1709670078151,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -139,8 +139,8 @@\n     for _ in range(lines_removed):\r\n         new_board.insert(0, [0 for _ in range(SCREEN_WIDTH // BLOCK_SIZE)])\r\n     return new_board, lines_removed\r\n \r\n-if _name_ == '_main_':\r\n+if __name__ == '_main_':\r\n     screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\r\n     clock = pygame.time.Clock()\r\n     main()\n\\ No newline at end of file\n"
                },
                {
                    "date": 1709670159671,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,146 +1,61 @@\n import pygame\r\n import random\r\n-import numpy as np\r\n \r\n-pygame.init()\r\n+# (Le reste du code reste inchangé...)\r\n \r\n-# Paramètres de base\r\n-SCREEN_WIDTH = 300\r\n-SCREEN_HEIGHT = 600\r\n-BLOCK_SIZE = 30\r\n-FPS = 30\r\n-COLOR_CHANGE_FREQUENCY = 1000  # changer de couleur toutes les 1000 frames\r\n+class Block:\r\n+    def __init__(self, shape):\r\n+        self.shape = shape\r\n+        self.color = (random.randint(50, 255), random.randint(50, 255), random.randint(50, 255))\r\n+        self.x = COLS // 2 - len(shape[0]) // 2\r\n+        self.y = 0\r\n \r\n-# Couleurs de l'arc-en-ciel\r\n-RAINBOW_COLORS = [\r\n-    (255, 0, 0),     # Rouge\r\n-    (255, 165, 0),   # Orange\r\n-    (255, 255, 0),   # Jaune\r\n-    (0, 255, 0),     # Vert\r\n-    (0, 0, 255),     # Bleu\r\n-    (75, 0, 130),    # Indigo\r\n-    (148, 0, 211)    # Violet\r\n-]\r\n+    # (Le reste du code reste inchangé...)\r\n \r\n-# Définition des formes de Tetris avec leurs couleurs correspondantes\r\n-tetris_shapes = [\r\n-    [[1, 1, 1],\r\n-     [0, 1, 0]],  # L\r\n-    [[0, 2, 2],\r\n-     [2, 2, 0]],  # S\r\n-    [[3, 3, 0],\r\n-     [0, 3, 3]],  # Z\r\n-    [[4, 0, 0],\r\n-     [4, 4, 4]],  # T\r\n-    [[0, 0, 5],\r\n-     [5, 5, 5]],  # J\r\n-    [[6, 6, 6, 6]],  # I\r\n-    [[7, 7],\r\n-     [7, 7]]  # O\r\n-]\r\n+def draw_board(screen, board):\r\n+    for y in range(ROWS):\r\n+        for x in range(COLS):\r\n+            if board[y][x] != 0:\r\n+                pygame.draw.rect(screen, board[y][x], (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n+                pygame.draw.rect(screen, BLACK, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), 1)\r\n \r\n-# Couleurs correspondantes aux formes de Tetris\r\n-tetris_colors = [\r\n-    (0, 0, 0),   # Noir\r\n-    (255, 0, 0), # Rouge\r\n-    (0, 255, 0), # Vert\r\n-    (0, 0, 255), # Bleu\r\n-    (255, 255, 0), # Jaune\r\n-    (255, 165, 0), # Orange\r\n-    (75, 0, 130),  # Indigo\r\n-    (148, 0, 211)  # Violet\r\n-]\r\n+def clear_lines(board):\r\n+    lines_to_clear = [i for i, row in enumerate(board) if all(cell != 0 for cell in row)]\r\n \r\n-def draw_matrix(matrix, offset):\r\n-    for y, row in enumerate(matrix):\r\n-        for x, val in enumerate(row):\r\n-            if val:\r\n-                pygame.draw.rect(screen, tetris_colors[val], pygame.Rect((offset[0] + x) * BLOCK_SIZE, (offset[1] + y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), 0)\r\n+    for line in lines_to_clear:\r\n+        del board[line]\r\n+        board.insert(0, [0] * COLS)\r\n \r\n-def new_piece():\r\n-    shape = random.choice(tetris_shapes)\r\n-    piece = {}\r\n-    piece['shape'] = shape\r\n-    piece['color'] = tetris_colors[tetris_shapes.index(shape)]\r\n-    piece['x'] = SCREEN_WIDTH // 2 - len(shape[0]) // 2\r\n-    piece['y'] = 0\r\n-    return piece\r\n+    return len(lines_to_clear)\r\n \r\n-def check_collision(board, piece, offset):\r\n-    off_x, off_y = offset\r\n-    for y, row in enumerate(piece):\r\n-        for x, val in enumerate(row):\r\n-            if val:\r\n-                if y + piece['y'] + off_y >= len(board) or \\\r\n-                   x + piece['x'] + off_x < 0 or \\\r\n-                   x + piece['x'] + off_x >= len(board[0]) or \\\r\n-                   board[y + piece['y'] + off_y][x + piece['x'] + off_x]:\r\n-                    return True\r\n-    return False\r\n+# (Le reste du code reste inchangé...)\r\n \r\n-def rotate(piece):\r\n-    rotated_shape = np.rot90(piece['shape'])\r\n-    return rotated_shape.tolist()\r\n-\r\n-def remove_row(board, row):\r\n-    del board[row]\r\n-    return [[0 for _ in range(SCREEN_WIDTH // BLOCK_SIZE)]] + board, 1\r\n-\r\n-def join_matrixes(board, piece, offset):\r\n-    off_x, off_y = offset\r\n-    for y, row in enumerate(piece):\r\n-        for x, val in enumerate(row):\r\n-            if val:\r\n-                board[y + piece['y'] + off_y][x + piece['x'] + off_x] = val\r\n-    return board\r\n-\r\n def main():\r\n-    board = [[0 for _ in range(SCREEN_WIDTH // BLOCK_SIZE)] for _ in range(SCREEN_HEIGHT // BLOCK_SIZE)]\r\n+    # (Le reste du code reste inchangé...)\r\n \r\n-    piece = new_piece()\r\n-    game_over = False\r\n     score = 0\r\n-    frame_count = 0\r\n-    current_color_index = 0\r\n \r\n-    # Initialisation de l'écran avec une couleur de l'arc-en-ciel\r\n-    screen.fill(RAINBOW_COLORS[current_color_index])\r\n+    while True:\r\n+        # (Le reste du code reste inchangé...)\r\n \r\n-    while not game_over:\r\n-        # Mise à jour de l'affichage de l'écran\r\n-        pygame.display.update()\r\n+        # Déplacer le bloc vers le bas\r\n+        current_block.move_down()\r\n+        if any((y >= ROWS or board[y][x] != 0) for x, y in current_block.get_blocks_positions()):\r\n+            current_block.move_up()\r\n+            for x, y in current_block.get_blocks_positions():\r\n+                board[y][x] = current_block.color\r\n+            score += clear_lines(board)  # Mettre à jour le score en fonction des lignes complètes\r\n+            current_block = next_block\r\n+            next_block = Block(random.choice(SHAPES))\r\n \r\n-        # Gestion des événements\r\n\\ No newline at end of file\n-        for event in pygame.event.get():\r\n-            if event.type == pygame.QUIT:\r\n-                game_over = True\r\n+        # Dessiner le tableau\r\n+        draw_board(screen, board)\r\n \r\n-        # Logique du jeu ici...\r\n+        # (Le reste du code reste inchangé...)\r\n \r\n-        # Incrémenter le compteur de frames\r\n-        frame_count += 1\r\n+        pygame.display.set_caption(f\"Tetris - Score: {score}\")\r\n \r\n-        # Changer la couleur de l'arrière-plan toutes les COLOR_CHANGE_FREQUENCY frames\r\n-        if frame_count >= COLOR_CHANGE_FREQUENCY:\r\n-            frame_count = 0\r\n-            current_color_index = (current_color_index + 1) % len(RAINBOW_COLORS)\r\n-            screen.fill(RAINBOW_COLORS[current_color_index])\r\n+# (Le reste du code reste inchangé...)\r\n \r\n-    pygame.quit()\r\n-\r\n-def remove_completed_lines(board):\r\n-    lines_removed = 0\r\n-    new_board = []\r\n-    for row in range(len(board)):\r\n-        if not all(board[row]):\r\n-            new_board.append(board[row])\r\n-        else:\r\n-            lines_removed += 1\r\n-    for _ in range(lines_removed):\r\n-        new_board.insert(0, [0 for _ in range(SCREEN_WIDTH // BLOCK_SIZE)])\r\n-    return new_board, lines_removed\r\n-\r\n-if __name__ == '_main_':\r\n-    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\r\n-    clock = pygame.time.Clock()\r\n-    main()\n+if __name__ == \"__main__\":\r\n+    main()\r\n"
                },
                {
                    "date": 1709670177289,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,61 +1,154 @@\n import pygame\r\n import random\r\n \r\n-# (Le reste du code reste inchangé...)\r\n+# Définition des constantes\r\n+SCREEN_WIDTH = 800\r\n+SCREEN_HEIGHT = 600\r\n+BLOCK_SIZE = 30\r\n+ROWS = 20\r\n+COLS = 10\r\n+WHITE = (255, 255, 255)\r\n+BLACK = (0, 0, 0)\r\n \r\n+# Formes des blocs\r\n+SHAPES = [\r\n+    [[1, 1, 1],\r\n+     [0, 1, 0]],\r\n+\r\n+    [[0, 2, 2],\r\n+     [2, 2, 0]],\r\n+\r\n+    [[3, 3],\r\n+     [3, 3]],\r\n+\r\n+    [[4, 4, 4, 4]],\r\n+\r\n+    [[0, 5, 0],\r\n+     [5, 5, 5]],\r\n+\r\n+    [[6, 0],\r\n+     [6, 0],\r\n+     [6, 6]],\r\n+\r\n+    [[0, 7],\r\n+     [0, 7],\r\n+     [7, 7]]\r\n+]\r\n+\r\n+\r\n class Block:\r\n     def __init__(self, shape):\r\n         self.shape = shape\r\n         self.color = (random.randint(50, 255), random.randint(50, 255), random.randint(50, 255))\r\n         self.x = COLS // 2 - len(shape[0]) // 2\r\n         self.y = 0\r\n \r\n-    # (Le reste du code reste inchangé...)\r\n+    def move_down(self):\r\n+        self.y += 1\r\n \r\n+    def move_left(self):\r\n+        self.x -= 1\r\n+\r\n+    def move_right(self):\r\n+        self.x += 1\r\n+\r\n+    def rotate(self):\r\n+        self.shape = [[self.shape[y][x] for y in range(len(self.shape))] for x in range(len(self.shape[0]))[::-1]]\r\n+\r\n+    def get_blocks_positions(self):\r\n+        positions = []\r\n+        for y in range(len(self.shape)):\r\n+            for x in range(len(self.shape[y])):\r\n+                if self.shape[y][x] != 0:\r\n+                    positions.append((self.x + x, self.y + y))\r\n+        return positions\r\n+\r\n+\r\n def draw_board(screen, board):\r\n     for y in range(ROWS):\r\n         for x in range(COLS):\r\n             if board[y][x] != 0:\r\n-                pygame.draw.rect(screen, board[y][x], (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n+                pygame.draw.rect(screen, WHITE, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n                 pygame.draw.rect(screen, BLACK, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), 1)\r\n \r\n-def clear_lines(board):\r\n-    lines_to_clear = [i for i, row in enumerate(board) if all(cell != 0 for cell in row)]\r\n \r\n-    for line in lines_to_clear:\r\n-        del board[line]\r\n-        board.insert(0, [0] * COLS)\r\n+def remove_completed_rows(board):\r\n+    completed_rows = 0\r\n+    for y in range(ROWS):\r\n+        if all(board[y]):\r\n+            del board[y]\r\n+            board.insert(0, [0] * COLS)\r\n+            completed_rows += 1\r\n+    return completed_rows\r\n \r\n-    return len(lines_to_clear)\r\n \r\n-# (Le reste du code reste inchangé...)\r\n-\r\n def main():\r\n-    # (Le reste du code reste inchangé...)\r\n+    pygame.init()\r\n+    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\r\n+    pygame.display.set_caption(\"Tetris\")\r\n+    clock = pygame.time.Clock()\r\n \r\n+    board = [[0] * COLS for _ in range(ROWS)]\r\n     score = 0\r\n \r\n+    current_block = Block(random.choice(SHAPES))\r\n+    next_block = Block(random.choice(SHAPES))\r\n+\r\n+    font = pygame.font.Font(None, 36)\r\n+\r\n     while True:\r\n-        # (Le reste du code reste inchangé...)\r\n+        screen.fill(BLACK)\r\n \r\n+        # Contrôles\r\n+        for event in pygame.event.get():\r\n+            if event.type == pygame.QUIT:\r\n+                pygame.quit()\r\n+                return\r\n+            elif event.type == pygame.KEYDOWN:\r\n+                if event.key == pygame.K_LEFT:\r\n+                    current_block.move_left()\r\n+                    if any((x < 0 or board[y][x] != 0) for x, y in current_block.get_blocks_positions()):\r\n+                        current_block.move_right()\r\n+                elif event.key == pygame.K_RIGHT:\r\n+                    current_block.move_right()\r\n+                    if any((x >= COLS or board[y][x] != 0) for x, y in current_block.get_blocks_positions()):\r\n+                        current_block.move_left()\r\n+                elif event.key == pygame.K_DOWN:\r\n+                    current_block.move_down()\r\n+                    if any((y >= ROWS or board[y][x] != 0) for x, y in current_block.get_blocks_positions()):\r\n+                        current_block.move_up()\r\n+                elif event.key == pygame.K_SPACE:\r\n+                    current_block.rotate()\r\n+                    if any((x < 0 or x >= COLS or y >= ROWS or board[y][x] != 0) for x, y in\r\n+                           current_block.get_blocks_positions()):\r\n+                        current_block.rotate()\r\n+\r\n         # Déplacer le bloc vers le bas\r\n         current_block.move_down()\r\n         if any((y >= ROWS or board[y][x] != 0) for x, y in current_block.get_blocks_positions()):\r\n             current_block.move_up()\r\n             for x, y in current_block.get_blocks_positions():\r\n                 board[y][x] = current_block.color\r\n-            score += clear_lines(board)  # Mettre à jour le score en fonction des lignes complètes\r\n+            completed_rows = remove_completed_rows(board)\r\n+            score += completed_rows * 100\r\n+\r\n             current_block = next_block\r\n             next_block = Block(random.choice(SHAPES))\r\n \r\n         # Dessiner le tableau\r\n         draw_board(screen, board)\r\n \r\n-        # (Le reste du code reste inchangé...)\r\n+        # Dessiner le bloc courant\r\n+        for x, y in current_block.get_blocks_positions():\r\n+            pygame.draw.rect(screen, current_block.color, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n \r\n-        pygame.display.set_caption(f\"Tetris - Score: {score}\")\r\n+        # Afficher le score\r\n+        score_text = font.render(f\"Score: {score}\", True, WHITE)\r\n+        screen.blit(score_text, (10, 10))\r\n \r\n-# (Le reste du code reste inchangé...)\r\n+        pygame.display.flip()\r\n+        clock.tick(5)\r\n \r\n+\r\n if __name__ == \"__main__\":\r\n     main()\r\n"
                },
                {
                    "date": 1709670292214,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,37 +11,24 @@\n BLACK = (0, 0, 0)\r\n \r\n # Formes des blocs\r\n SHAPES = [\r\n-    [[1, 1, 1],\r\n-     [0, 1, 0]],\r\n-\r\n-    [[0, 2, 2],\r\n-     [2, 2, 0]],\r\n-\r\n-    [[3, 3],\r\n-     [3, 3]],\r\n-\r\n-    [[4, 4, 4, 4]],\r\n-\r\n-    [[0, 5, 0],\r\n-     [5, 5, 5]],\r\n-\r\n-    [[6, 0],\r\n-     [6, 0],\r\n-     [6, 6]],\r\n-\r\n-    [[0, 7],\r\n-     [0, 7],\r\n-     [7, 7]]\r\n+    [[1, 1, 1, 1]],\r\n+    [[1, 1, 1], [0, 1, 0]],\r\n+    [[1, 1, 1], [1, 0, 0]],\r\n+    [[1, 1], [1, 1]],\r\n+    [[0, 1, 1], [1, 1, 0]],\r\n+    [[1, 1, 0], [0, 1, 1]],\r\n+    [[0, 1], [1, 1], [1, 0]]\r\n ]\r\n \r\n \r\n class Block:\r\n-    def __init__(self, shape):\r\n-        self.shape = shape\r\n+    def __init__(self):\r\n+        self.shape = random.choice(SHAPES)\r\n         self.color = (random.randint(50, 255), random.randint(50, 255), random.randint(50, 255))\r\n-        self.x = COLS // 2 - len(shape[0]) // 2\r\n+        self.rotation = 0\r\n+        self.x = COLS // 2 - len(self.shape[0]) // 2\r\n         self.y = 0\r\n \r\n     def move_down(self):\r\n         self.y += 1\r\n@@ -52,24 +39,25 @@\n     def move_right(self):\r\n         self.x += 1\r\n \r\n     def rotate(self):\r\n-        self.shape = [[self.shape[y][x] for y in range(len(self.shape))] for x in range(len(self.shape[0]))[::-1]]\r\n+        self.rotation = (self.rotation + 1) % 4\r\n \r\n     def get_blocks_positions(self):\r\n         positions = []\r\n-        for y in range(len(self.shape)):\r\n-            for x in range(len(self.shape[y])):\r\n-                if self.shape[y][x] != 0:\r\n+        shape = self.shape[self.rotation]\r\n+        for y in range(len(shape)):\r\n+            for x in range(len(shape[y])):\r\n+                if shape[y][x] == 1:\r\n                     positions.append((self.x + x, self.y + y))\r\n         return positions\r\n \r\n \r\n def draw_board(screen, board):\r\n     for y in range(ROWS):\r\n         for x in range(COLS):\r\n             if board[y][x] != 0:\r\n-                pygame.draw.rect(screen, WHITE, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n+                pygame.draw.rect(screen, board[y][x], (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n                 pygame.draw.rect(screen, BLACK, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), 1)\r\n \r\n \r\n def remove_completed_rows(board):\r\n@@ -89,14 +77,13 @@\n     clock = pygame.time.Clock()\r\n \r\n     board = [[0] * COLS for _ in range(ROWS)]\r\n     score = 0\r\n+    font = pygame.font.Font(None, 36)\r\n \r\n-    current_block = Block(random.choice(SHAPES))\r\n-    next_block = Block(random.choice(SHAPES))\r\n+    current_block = Block()\r\n+    next_block = Block()\r\n \r\n-    font = pygame.font.Font(None, 36)\r\n-\r\n     while True:\r\n         screen.fill(BLACK)\r\n \r\n         # Contrôles\r\n@@ -116,9 +103,9 @@\n                 elif event.key == pygame.K_DOWN:\r\n                     current_block.move_down()\r\n                     if any((y >= ROWS or board[y][x] != 0) for x, y in current_block.get_blocks_positions()):\r\n                         current_block.move_up()\r\n-                elif event.key == pygame.K_SPACE:\r\n+                elif event.key == pygame.K_UP:\r\n                     current_block.rotate()\r\n                     if any((x < 0 or x >= COLS or y >= ROWS or board[y][x] != 0) for x, y in\r\n                            current_block.get_blocks_positions()):\r\n                         current_block.rotate()\r\n@@ -132,9 +119,9 @@\n             completed_rows = remove_completed_rows(board)\r\n             score += completed_rows * 100\r\n \r\n             current_block = next_block\r\n-            next_block = Block(random.choice(SHAPES))\r\n+            next_block = Block()\r\n \r\n         # Dessiner le tableau\r\n         draw_board(screen, board)\r\n \r\n@@ -151,4 +138,5 @@\n \r\n \r\n if __name__ == \"__main__\":\r\n     main()\r\n+```\r\n"
                },
                {
                    "date": 1709670317155,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -138,5 +138,4 @@\n \r\n \r\n if __name__ == \"__main__\":\r\n     main()\r\n-```\r\n"
                },
                {
                    "date": 1709670355914,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -11,24 +11,37 @@\n BLACK = (0, 0, 0)\r\n \r\n # Formes des blocs\r\n SHAPES = [\r\n-    [[1, 1, 1, 1]],\r\n-    [[1, 1, 1], [0, 1, 0]],\r\n-    [[1, 1, 1], [1, 0, 0]],\r\n-    [[1, 1], [1, 1]],\r\n-    [[0, 1, 1], [1, 1, 0]],\r\n-    [[1, 1, 0], [0, 1, 1]],\r\n-    [[0, 1], [1, 1], [1, 0]]\r\n+    [[1, 1, 1],\r\n+     [0, 1, 0]],\r\n+\r\n+    [[0, 2, 2],\r\n+     [2, 2, 0]],\r\n+\r\n+    [[3, 3],\r\n+     [3, 3]],\r\n+\r\n+    [[4, 4, 4, 4]],\r\n+\r\n+    [[0, 5, 0],\r\n+     [5, 5, 5]],\r\n+\r\n+    [[6, 0],\r\n+     [6, 0],\r\n+     [6, 6]],\r\n+\r\n+    [[0, 7],\r\n+     [0, 7],\r\n+     [7, 7]]\r\n ]\r\n \r\n \r\n class Block:\r\n-    def __init__(self):\r\n-        self.shape = random.choice(SHAPES)\r\n+    def __init__(self, shape):\r\n+        self.shape = shape\r\n         self.color = (random.randint(50, 255), random.randint(50, 255), random.randint(50, 255))\r\n-        self.rotation = 0\r\n-        self.x = COLS // 2 - len(self.shape[0]) // 2\r\n+        self.x = COLS // 2 - len(shape[0]) // 2\r\n         self.y = 0\r\n \r\n     def move_down(self):\r\n         self.y += 1\r\n@@ -39,25 +52,24 @@\n     def move_right(self):\r\n         self.x += 1\r\n \r\n     def rotate(self):\r\n-        self.rotation = (self.rotation + 1) % 4\r\n+        self.shape = [[self.shape[y][x] for y in range(len(self.shape))] for x in range(len(self.shape[0]))[::-1]]\r\n \r\n     def get_blocks_positions(self):\r\n         positions = []\r\n-        shape = self.shape[self.rotation]\r\n-        for y in range(len(shape)):\r\n-            for x in range(len(shape[y])):\r\n-                if shape[y][x] == 1:\r\n+        for y in range(len(self.shape)):\r\n+            for x in range(len(self.shape[y])):\r\n+                if self.shape[y][x] != 0:\r\n                     positions.append((self.x + x, self.y + y))\r\n         return positions\r\n \r\n \r\n def draw_board(screen, board):\r\n     for y in range(ROWS):\r\n         for x in range(COLS):\r\n             if board[y][x] != 0:\r\n-                pygame.draw.rect(screen, board[y][x], (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n+                pygame.draw.rect(screen, WHITE, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n                 pygame.draw.rect(screen, BLACK, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), 1)\r\n \r\n \r\n def remove_completed_rows(board):\r\n@@ -77,13 +89,14 @@\n     clock = pygame.time.Clock()\r\n \r\n     board = [[0] * COLS for _ in range(ROWS)]\r\n     score = 0\r\n+\r\n+    current_block = Block(random.choice(SHAPES))\r\n+    next_block = Block(random.choice(SHAPES))\r\n+\r\n     font = pygame.font.Font(None, 36)\r\n \r\n-    current_block = Block()\r\n-    next_block = Block()\r\n-\r\n     while True:\r\n         screen.fill(BLACK)\r\n \r\n         # Contrôles\r\n@@ -103,9 +116,9 @@\n                 elif event.key == pygame.K_DOWN:\r\n                     current_block.move_down()\r\n                     if any((y >= ROWS or board[y][x] != 0) for x, y in current_block.get_blocks_positions()):\r\n                         current_block.move_up()\r\n-                elif event.key == pygame.K_UP:\r\n+                elif event.key == pygame.K_SPACE:\r\n                     current_block.rotate()\r\n                     if any((x < 0 or x >= COLS or y >= ROWS or board[y][x] != 0) for x, y in\r\n                            current_block.get_blocks_positions()):\r\n                         current_block.rotate()\r\n@@ -119,9 +132,9 @@\n             completed_rows = remove_completed_rows(board)\r\n             score += completed_rows * 100\r\n \r\n             current_block = next_block\r\n-            next_block = Block()\r\n+            next_block = Block(random.choice(SHAPES))\r\n \r\n         # Dessiner le tableau\r\n         draw_board(screen, board)\r\n \r\n"
                },
                {
                    "date": 1709670455658,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,8 +8,9 @@\n ROWS = 20\r\n COLS = 10\r\n WHITE = (255, 255, 255)\r\n BLACK = (0, 0, 0)\r\n+FONT_SIZE = 36\r\n \r\n # Formes des blocs\r\n SHAPES = [\r\n     [[1, 1, 1],\r\n@@ -34,8 +35,10 @@\n      [0, 7],\r\n      [7, 7]]\r\n ]\r\n \r\n+# Définition des événements personnalisés\r\n+GAME_OVER_EVENT = pygame.USEREVENT + 1\r\n \r\n class Block:\r\n     def __init__(self, shape):\r\n         self.shape = shape\r\n@@ -67,35 +70,25 @@\n def draw_board(screen, board):\r\n     for y in range(ROWS):\r\n         for x in range(COLS):\r\n             if board[y][x] != 0:\r\n-                pygame.draw.rect(screen, WHITE, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n+                pygame.draw.rect(screen, board[y][x], (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n                 pygame.draw.rect(screen, BLACK, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), 1)\r\n \r\n \r\n-def remove_completed_rows(board):\r\n-    completed_rows = 0\r\n-    for y in range(ROWS):\r\n-        if all(board[y]):\r\n-            del board[y]\r\n-            board.insert(0, [0] * COLS)\r\n-            completed_rows += 1\r\n-    return completed_rows\r\n-\r\n-\r\n def main():\r\n     pygame.init()\r\n     screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\r\n     pygame.display.set_caption(\"Tetris\")\r\n     clock = pygame.time.Clock()\r\n+    font = pygame.font.Font(None, FONT_SIZE)\r\n \r\n     board = [[0] * COLS for _ in range(ROWS)]\r\n-    score = 0\r\n \r\n     current_block = Block(random.choice(SHAPES))\r\n     next_block = Block(random.choice(SHAPES))\r\n \r\n-    font = pygame.font.Font(None, 36)\r\n+    score = 0\r\n \r\n     while True:\r\n         screen.fill(BLACK)\r\n \r\n@@ -128,22 +121,30 @@\n         if any((y >= ROWS or board[y][x] != 0) for x, y in current_block.get_blocks_positions()):\r\n             current_block.move_up()\r\n             for x, y in current_block.get_blocks_positions():\r\n                 board[y][x] = current_block.color\r\n-            completed_rows = remove_completed_rows(board)\r\n-            score += completed_rows * 100\r\n-\r\n             current_block = next_block\r\n             next_block = Block(random.choice(SHAPES))\r\n \r\n+            # Vérification des lignes complètes\r\n+            full_rows = [i for i, row in enumerate(board) if all(cell != 0 for cell in row)]\r\n+            for row in full_rows:\r\n+                del board[row]\r\n+                board.insert(0, [0] * COLS)\r\n+                score += 100\r\n+\r\n+            # Vérification du game over\r\n+            if any(cell != 0 for cell in board[0]):\r\n+                pygame.event.post(pygame.event.Event(GAME_OVER_EVENT))\r\n+\r\n         # Dessiner le tableau\r\n         draw_board(screen, board)\r\n \r\n         # Dessiner le bloc courant\r\n         for x, y in current_block.get_blocks_positions():\r\n             pygame.draw.rect(screen, current_block.color, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n \r\n-        # Afficher le score\r\n+        # Affichage du score\r\n         score_text = font.render(f\"Score: {score}\", True, WHITE)\r\n         screen.blit(score_text, (10, 10))\r\n \r\n         pygame.display.flip()\r\n"
                },
                {
                    "date": 1709670580142,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,9 +8,8 @@\n ROWS = 20\r\n COLS = 10\r\n WHITE = (255, 255, 255)\r\n BLACK = (0, 0, 0)\r\n-FONT_SIZE = 36\r\n \r\n # Formes des blocs\r\n SHAPES = [\r\n     [[1, 1, 1],\r\n@@ -35,11 +34,8 @@\n      [0, 7],\r\n      [7, 7]]\r\n ]\r\n \r\n-# Définition des événements personnalisés\r\n-GAME_OVER_EVENT = pygame.USEREVENT + 1\r\n-\r\n class Block:\r\n     def __init__(self, shape):\r\n         self.shape = shape\r\n         self.color = (random.randint(50, 255), random.randint(50, 255), random.randint(50, 255))\r\n@@ -79,9 +75,8 @@\n     pygame.init()\r\n     screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\r\n     pygame.display.set_caption(\"Tetris\")\r\n     clock = pygame.time.Clock()\r\n-    font = pygame.font.Font(None, FONT_SIZE)\r\n \r\n     board = [[0] * COLS for _ in range(ROWS)]\r\n \r\n     current_block = Block(random.choice(SHAPES))\r\n@@ -124,30 +119,37 @@\n                 board[y][x] = current_block.color\r\n             current_block = next_block\r\n             next_block = Block(random.choice(SHAPES))\r\n \r\n-            # Vérification des lignes complètes\r\n-            full_rows = [i for i, row in enumerate(board) if all(cell != 0 for cell in row)]\r\n-            for row in full_rows:\r\n-                del board[row]\r\n-                board.insert(0, [0] * COLS)\r\n-                score += 100\r\n+            # Supprimer les lignes complètes et mettre à jour le score\r\n+            lines_cleared = 0\r\n+            for y in range(ROWS):\r\n+                if all(board[y]):\r\n+                    del board[y]\r\n+                    board.insert(0, [0] * COLS)\r\n+                    lines_cleared += 1\r\n+            score += lines_cleared * 100\r\n \r\n-            # Vérification du game over\r\n-            if any(cell != 0 for cell in board[0]):\r\n-                pygame.event.post(pygame.event.Event(GAME_OVER_EVENT))\r\n-\r\n         # Dessiner le tableau\r\n         draw_board(screen, board)\r\n \r\n         # Dessiner le bloc courant\r\n         for x, y in current_block.get_blocks_positions():\r\n             pygame.draw.rect(screen, current_block.color, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n \r\n-        # Affichage du score\r\n-        score_text = font.render(f\"Score: {score}\", True, WHITE)\r\n-        screen.blit(score_text, (10, 10))\r\n+        # Dessiner le bloc suivant\r\n+        font = pygame.font.SysFont(None, 36)\r\n+        next_text = font.render(\"Next Block:\", True, WHITE)\r\n+        screen.blit(next_text, (SCREEN_WIDTH - 200, 50))\r\n+        for y, row in enumerate(next_block.shape):\r\n+            for x, val in enumerate(row):\r\n+                if val != 0:\r\n+                    pygame.draw.rect(screen, next_block.color, ((x + COLS + 1) * BLOCK_SIZE, (y + 2) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n \r\n+        # Afficher le score\r\n+        score_text = font.render(\"Score: \" + str(score), True, WHITE)\r\n+        screen.blit(score_text, (SCREEN_WIDTH - 200, 200))\r\n+\r\n         pygame.display.flip()\r\n         clock.tick(5)\r\n \r\n \r\n"
                },
                {
                    "date": 1709670751819,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,7 @@\n import pygame\r\n import random\r\n+import time\r\n \r\n # Définition des constantes\r\n SCREEN_WIDTH = 800\r\n SCREEN_HEIGHT = 600\r\n@@ -8,8 +9,9 @@\n ROWS = 20\r\n COLS = 10\r\n WHITE = (255, 255, 255)\r\n BLACK = (0, 0, 0)\r\n+FONT_SIZE = 36\r\n \r\n # Formes des blocs\r\n SHAPES = [\r\n     [[1, 1, 1],\r\n@@ -34,8 +36,9 @@\n      [0, 7],\r\n      [7, 7]]\r\n ]\r\n \r\n+# Définition de la classe Block\r\n class Block:\r\n     def __init__(self, shape):\r\n         self.shape = shape\r\n         self.color = (random.randint(50, 255), random.randint(50, 255), random.randint(50, 255))\r\n@@ -61,17 +64,17 @@\n                 if self.shape[y][x] != 0:\r\n                     positions.append((self.x + x, self.y + y))\r\n         return positions\r\n \r\n-\r\n+# Dessiner le tableau\r\n def draw_board(screen, board):\r\n     for y in range(ROWS):\r\n         for x in range(COLS):\r\n             if board[y][x] != 0:\r\n-                pygame.draw.rect(screen, board[y][x], (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n+                pygame.draw.rect(screen, WHITE, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n                 pygame.draw.rect(screen, BLACK, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), 1)\r\n \r\n-\r\n+# Fonction principale\r\n def main():\r\n     pygame.init()\r\n     screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\r\n     pygame.display.set_caption(\"Tetris\")\r\n@@ -81,11 +84,14 @@\n \r\n     current_block = Block(random.choice(SHAPES))\r\n     next_block = Block(random.choice(SHAPES))\r\n \r\n+    start_time = time.time()\r\n+    game_over = False\r\n+\r\n     score = 0\r\n \r\n-    while True:\r\n+    while not game_over:\r\n         screen.fill(BLACK)\r\n \r\n         # Contrôles\r\n         for event in pygame.event.get():\r\n@@ -110,25 +116,22 @@\n                     if any((x < 0 or x >= COLS or y >= ROWS or board[y][x] != 0) for x, y in\r\n                            current_block.get_blocks_positions()):\r\n                         current_block.rotate()\r\n \r\n-        # Déplacer le bloc vers le bas\r\n+        # Empiler les blocs\r\n         current_block.move_down()\r\n         if any((y >= ROWS or board[y][x] != 0) for x, y in current_block.get_blocks_positions()):\r\n             current_block.move_up()\r\n             for x, y in current_block.get_blocks_positions():\r\n                 board[y][x] = current_block.color\r\n             current_block = next_block\r\n             next_block = Block(random.choice(SHAPES))\r\n-\r\n-            # Supprimer les lignes complètes et mettre à jour le score\r\n-            lines_cleared = 0\r\n-            for y in range(ROWS):\r\n-                if all(board[y]):\r\n-                    del board[y]\r\n+            # Vérifier les lignes complètes\r\n+            for i, row in enumerate(board):\r\n+                if all(cell != 0 for cell in row):\r\n+                    score += 10\r\n+                    del board[i]\r\n                     board.insert(0, [0] * COLS)\r\n-                    lines_cleared += 1\r\n-            score += lines_cleared * 100\r\n \r\n         # Dessiner le tableau\r\n         draw_board(screen, board)\r\n \r\n@@ -136,22 +139,34 @@\n         for x, y in current_block.get_blocks_positions():\r\n             pygame.draw.rect(screen, current_block.color, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n \r\n         # Dessiner le bloc suivant\r\n-        font = pygame.font.SysFont(None, 36)\r\n+        font = pygame.font.Font(None, FONT_SIZE)\r\n         next_text = font.render(\"Next Block:\", True, WHITE)\r\n         screen.blit(next_text, (SCREEN_WIDTH - 200, 50))\r\n-        for y, row in enumerate(next_block.shape):\r\n-            for x, val in enumerate(row):\r\n-                if val != 0:\r\n-                    pygame.draw.rect(screen, next_block.color, ((x + COLS + 1) * BLOCK_SIZE, (y + 2) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n+        for x, y in next_block.get_blocks_positions():\r\n+            pygame.draw.rect(screen, next_block.color, ((x + COLS + 1) * BLOCK_SIZE, (y + 1) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n \r\n         # Afficher le score\r\n         score_text = font.render(\"Score: \" + str(score), True, WHITE)\r\n-        screen.blit(score_text, (SCREEN_WIDTH - 200, 200))\r\n+        screen.blit(score_text, (SCREEN_WIDTH - 200, 150))\r\n \r\n+        # Mettre à jour l'affichage\r\n         pygame.display.flip()\r\n+\r\n+        # Vérifier si le temps est écoulé\r\n+        if time.time() - start_time >= 60:\r\n+            game_over = True\r\n+\r\n         clock.tick(5)\r\n \r\n+    # Afficher le score final\r\n+    screen.fill(BLACK)\r\n+    final_score_text = font.render(\"Final Score: \" + str(score), True, WHITE)\r\n+    screen.blit(final_score_text, (SCREEN_WIDTH // 2 - FONT_SIZE * 4, SCREEN_HEIGHT // 2 - FONT_SIZE // 2))\r\n+    pygame.display.flip()\r\n+    pygame.time.wait(3000)  # Attendre quelques secondes avant de quitter\r\n+    pygame.quit()\r\n \r\n+\r\n if __name__ == \"__main__\":\r\n     main()\r\n"
                },
                {
                    "date": 1709670902160,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -72,8 +72,12 @@\n             if board[y][x] != 0:\r\n                 pygame.draw.rect(screen, WHITE, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n                 pygame.draw.rect(screen, BLACK, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), 1)\r\n \r\n+# Vérifier le Game Over\r\n+def check_game_over(board):\r\n+    return any(cell != 0 for cell in board[0])\r\n+\r\n # Fonction principale\r\n def main():\r\n     pygame.init()\r\n     screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\r\n@@ -152,18 +156,18 @@\n \r\n         # Mettre à jour l'affichage\r\n         pygame.display.flip()\r\n \r\n-        # Vérifier si le temps est écoulé\r\n-        if time.time() - start_time >= 60:\r\n+        # Vérifier le Game Over\r\n+        if check_game_over(board):\r\n             game_over = True\r\n \r\n         clock.tick(5)\r\n \r\n-    # Afficher le score final\r\n+    # Afficher le Game Over\r\n     screen.fill(BLACK)\r\n-    final_score_text = font.render(\"Final Score: \" + str(score), True, WHITE)\r\n-    screen.blit(final_score_text, (SCREEN_WIDTH // 2 - FONT_SIZE * 4, SCREEN_HEIGHT // 2 - FONT_SIZE // 2))\r\n+    game_over_text = font.render(\"Game Over\", True, WHITE)\r\n+    screen.blit(game_over_text, (SCREEN_WIDTH // 2 - FONT_SIZE * 4, SCREEN_HEIGHT // 2 - FONT_SIZE // 2))\r\n     pygame.display.flip()\r\n     pygame.time.wait(3000)  # Attendre quelques secondes avant de quitter\r\n     pygame.quit()\r\n \r\n"
                },
                {
                    "date": 1709671158070,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,51 +1,67 @@\n import pygame\r\n import random\r\n-import time\r\n \r\n-# Définition des constantes\r\n-SCREEN_WIDTH = 800\r\n-SCREEN_HEIGHT = 600\r\n+pygame.init()\r\n+\r\n+# Définition des variables globales\r\n+SCREEN_WIDTH, SCREEN_HEIGHT = 300, 600\r\n BLOCK_SIZE = 30\r\n-ROWS = 20\r\n-COLS = 10\r\n+GRID_WIDTH, GRID_HEIGHT = SCREEN_WIDTH // BLOCK_SIZE, SCREEN_HEIGHT // BLOCK_SIZE\r\n WHITE = (255, 255, 255)\r\n BLACK = (0, 0, 0)\r\n-FONT_SIZE = 36\r\n+RED = (255, 0, 0)\r\n+GREEN = (0, 255, 0)\r\n+BLUE = (0, 0, 255)\r\n+YELLOW = (255, 255, 0)\r\n+CYAN = (0, 255, 255)\r\n+MAGENTA = (255, 0, 255)\r\n+ORANGE = (255, 165, 0)\r\n+GRAY = (128, 128, 128)\r\n \r\n-# Formes des blocs\r\n SHAPES = [\r\n     [[1, 1, 1],\r\n      [0, 1, 0]],\r\n \r\n     [[0, 2, 2],\r\n      [2, 2, 0]],\r\n \r\n-    [[3, 3],\r\n-     [3, 3]],\r\n+    [[3, 3, 0],\r\n+     [0, 3, 3]],\r\n \r\n-    [[4, 4, 4, 4]],\r\n+    [[4, 0, 0],\r\n+     [4, 4, 4]],\r\n \r\n-    [[0, 5, 0],\r\n-     [5, 5, 5]],\r\n+    [[0, 0, 5, 0],\r\n+     [5, 5, 5, 5]],\r\n \r\n-    [[6, 0],\r\n-     [6, 0],\r\n-     [6, 6]],\r\n-\r\n-    [[0, 7],\r\n-     [0, 7],\r\n-     [7, 7]]\r\n+    [[0, 6, 0],\r\n+     [6, 6, 6],\r\n+     [0, 0, 0]]\r\n ]\r\n \r\n-# Définition de la classe Block\r\n-class Block:\r\n-    def __init__(self, shape):\r\n-        self.shape = shape\r\n-        self.color = (random.randint(50, 255), random.randint(50, 255), random.randint(50, 255))\r\n-        self.x = COLS // 2 - len(shape[0]) // 2\r\n-        self.y = 0\r\n+class Piece:\r\n+    def __init__(self, x, y):\r\n+        self.x = x\r\n+        self.y = y\r\n+        self.shape = random.choice(SHAPES)\r\n+        self.color = random.choice([RED, GREEN, BLUE, YELLOW, CYAN, MAGENTA, ORANGE])\r\n+        self.rotation = 0\r\n \r\n+    def rotate(self):\r\n+        self.rotation = (self.rotation + 1) % 4\r\n+        self.shape = self._rotate_shape()\r\n+\r\n+    def _rotate_shape(self):\r\n+        return [[self.shape[y][x] for y in range(len(self.shape))] for x in range(len(self.shape[0])-1, -1, -1)]\r\n+\r\n+    def draw(self, screen):\r\n+        for y in range(len(self.shape)):\r\n+            for x in range(len(self.shape[y])):\r\n+                if self.shape[y][x]:\r\n+                    pygame.draw.rect(screen, self.color, (self.x*BLOCK_SIZE + x*BLOCK_SIZE, self.y*BLOCK_SIZE + y*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n+                    pygame.draw.rect(screen, WHITE, (self.x*BLOCK_SIZE + x*BLOCK_SIZE, self.y*BLOCK_SIZE + y*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), 2)\r\n+\r\n     def move_down(self):\r\n         self.y += 1\r\n \r\n     def move_left(self):\r\n@@ -53,124 +69,96 @@\n \r\n     def move_right(self):\r\n         self.x += 1\r\n \r\n-    def rotate(self):\r\n-        self.shape = [[self.shape[y][x] for y in range(len(self.shape))] for x in range(len(self.shape[0]))[::-1]]\r\n+    def check_collision(self, grid):\r\n+        for y in range(len(self.shape)):\r\n+            for x in range(len(self.shape[y])):\r\n+                if self.shape[y][x]:\r\n+                    if self.y + y >= GRID_HEIGHT or self.x + x < 0 or self.x + x >= GRID_WIDTH or grid[self.y + y][self.x + x]:\r\n+                        return True\r\n+        return False\r\n \r\n-    def get_blocks_positions(self):\r\n-        positions = []\r\n+    def lock_piece(self, grid):\r\n         for y in range(len(self.shape)):\r\n             for x in range(len(self.shape[y])):\r\n-                if self.shape[y][x] != 0:\r\n-                    positions.append((self.x + x, self.y + y))\r\n-        return positions\r\n+                if self.shape[y][x]:\r\n+                    grid[self.y + y][self.x + x] = self.color\r\n \r\n-# Dessiner le tableau\r\n-def draw_board(screen, board):\r\n-    for y in range(ROWS):\r\n-        for x in range(COLS):\r\n-            if board[y][x] != 0:\r\n-                pygame.draw.rect(screen, WHITE, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n-                pygame.draw.rect(screen, BLACK, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), 1)\r\n+def create_grid():\r\n+    return [[BLACK for _ in range(GRID_WIDTH)] for _ in range(GRID_HEIGHT)]\r\n \r\n-# Vérifier le Game Over\r\n-def check_game_over(board):\r\n-    return any(cell != 0 for cell in board[0])\r\n+def draw_grid(screen, grid):\r\n+    for y in range(GRID_HEIGHT):\r\n+        for x in range(GRID_WIDTH):\r\n+            pygame.draw.rect(screen, grid[y][x], (x*BLOCK_SIZE, y*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n+            pygame.draw.rect(screen, WHITE, (x*BLOCK_SIZE, y*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), 1)\r\n \r\n-# Fonction principale\r\n+def draw_next_piece(screen, piece):\r\n+    font = pygame.font.SysFont(None, 30)\r\n+    text = font.render('Next Piece:', True, WHITE)\r\n+    screen.blit(text, (SCREEN_WIDTH + 20, 50))\r\n+    for y in range(len(piece.shape)):\r\n+        for x in range(len(piece.shape[y])):\r\n+            if piece.shape[y][x]:\r\n+                pygame.draw.rect(screen, piece.color, (SCREEN_WIDTH + 20 + x*BLOCK_SIZE, 100 + y*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n+                pygame.draw.rect(screen, WHITE, (SCREEN_WIDTH + 20 + x*BLOCK_SIZE, 100 + y*BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), 2)\r\n+\r\n def main():\r\n-    pygame.init()\r\n-    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\r\n+    screen = pygame.display.set_mode((SCREEN_WIDTH + 200, SCREEN_HEIGHT))\r\n     pygame.display.set_caption(\"Tetris\")\r\n     clock = pygame.time.Clock()\r\n-\r\n-    board = [[0] * COLS for _ in range(ROWS)]\r\n-\r\n-    current_block = Block(random.choice(SHAPES))\r\n-    next_block = Block(random.choice(SHAPES))\r\n-\r\n-    start_time = time.time()\r\n     game_over = False\r\n+    grid = create_grid()\r\n+    piece = Piece(GRID_WIDTH // 2, 0)\r\n+    next_piece = Piece(GRID_WIDTH // 2, 0)\r\n \r\n-    score = 0\r\n-\r\n     while not game_over:\r\n         screen.fill(BLACK)\r\n+        piece.draw(screen)\r\n+        draw_next_piece(screen, next_piece)\r\n+        draw_grid(screen, grid)\r\n \r\n-        # Contrôles\r\n+        pygame.display.update()\r\n+\r\n         for event in pygame.event.get():\r\n             if event.type == pygame.QUIT:\r\n-                pygame.quit()\r\n-                return\r\n-            elif event.type == pygame.KEYDOWN:\r\n+                game_over = True\r\n+            if event.type == pygame.KEYDOWN:\r\n                 if event.key == pygame.K_LEFT:\r\n-                    current_block.move_left()\r\n-                    if any((x < 0 or board[y][x] != 0) for x, y in current_block.get_blocks_positions()):\r\n-                        current_block.move_right()\r\n-                elif event.key == pygame.K_RIGHT:\r\n-                    current_block.move_right()\r\n-                    if any((x >= COLS or board[y][x] != 0) for x, y in current_block.get_blocks_positions()):\r\n-                        current_block.move_left()\r\n-                elif event.key == pygame.K_DOWN:\r\n-                    current_block.move_down()\r\n-                    if any((y >= ROWS or board[y][x] != 0) for x, y in current_block.get_blocks_positions()):\r\n-                        current_block.move_up()\r\n-                elif event.key == pygame.K_SPACE:\r\n-                    current_block.rotate()\r\n-                    if any((x < 0 or x >= COLS or y >= ROWS or board[y][x] != 0) for x, y in\r\n-                           current_block.get_blocks_positions()):\r\n-                        current_block.rotate()\r\n+                    piece.move_left()\r\n+                    if piece.check_collision(grid):\r\n+                        piece.move_right()\r\n+                if event.key == pygame.K_RIGHT:\r\n+                    piece.move_right()\r\n+                    if piece.check_collision(grid):\r\n+                        piece.move_left()\r\n+                if event.key == pygame.K_DOWN:\r\n+                    piece.move_down()\r\n+                    if piece.check_collision(grid):\r\n+                        piece.move_up()\r\n+                        piece.lock_piece(grid)\r\n+                        piece = next_piece\r\n+                        next_piece = Piece(GRID_WIDTH // 2, 0)\r\n+                        if piece.check_collision(grid):\r\n+                            game_over = True\r\n+                if event.key == pygame.K_UP:\r\n+                    piece.rotate()\r\n+                    if piece.check_collision(grid):\r\n+                        piece.rotate_back()\r\n \r\n-        # Empiler les blocs\r\n-        current_block.move_down()\r\n-        if any((y >= ROWS or board[y][x] != 0) for x, y in current_block.get_blocks_positions()):\r\n-            current_block.move_up()\r\n-            for x, y in current_block.get_blocks_positions():\r\n-                board[y][x] = current_block.color\r\n-            current_block = next_block\r\n-            next_block = Block(random.choice(SHAPES))\r\n-            # Vérifier les lignes complètes\r\n-            for i, row in enumerate(board):\r\n-                if all(cell != 0 for cell in row):\r\n-                    score += 10\r\n-                    del board[i]\r\n-                    board.insert(0, [0] * COLS)\r\n+        if not game_over:\r\n+            piece.move_down()\r\n+            if piece.check_collision(grid):\r\n+                piece.move_up()\r\n+                piece.lock_piece(grid)\r\n+                piece = next_piece\r\n+                next_piece = Piece(GRID_WIDTH // 2, 0)\r\n+                if piece.check_collision(grid):\r\n+                    game_over = True\r\n \r\n-        # Dessiner le tableau\r\n-        draw_board(screen, board)\r\n-\r\n-        # Dessiner le bloc courant\r\n-        for x, y in current_block.get_blocks_positions():\r\n-            pygame.draw.rect(screen, current_block.color, (x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n-\r\n-        # Dessiner le bloc suivant\r\n-        font = pygame.font.Font(None, FONT_SIZE)\r\n-        next_text = font.render(\"Next Block:\", True, WHITE)\r\n-        screen.blit(next_text, (SCREEN_WIDTH - 200, 50))\r\n-        for x, y in next_block.get_blocks_positions():\r\n-            pygame.draw.rect(screen, next_block.color, ((x + COLS + 1) * BLOCK_SIZE, (y + 1) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE))\r\n-\r\n-        # Afficher le score\r\n-        score_text = font.render(\"Score: \" + str(score), True, WHITE)\r\n-        screen.blit(score_text, (SCREEN_WIDTH - 200, 150))\r\n-\r\n-        # Mettre à jour l'affichage\r\n-        pygame.display.flip()\r\n-\r\n-        # Vérifier le Game Over\r\n-        if check_game_over(board):\r\n-            game_over = True\r\n-\r\n         clock.tick(5)\r\n \r\n-    # Afficher le Game Over\r\n-    screen.fill(BLACK)\r\n-    game_over_text = font.render(\"Game Over\", True, WHITE)\r\n-    screen.blit(game_over_text, (SCREEN_WIDTH // 2 - FONT_SIZE * 4, SCREEN_HEIGHT // 2 - FONT_SIZE // 2))\r\n-    pygame.display.flip()\r\n-    pygame.time.wait(3000)  # Attendre quelques secondes avant de quitter\r\n     pygame.quit()\r\n \r\n-\r\n if __name__ == \"__main__\":\r\n     main()\r\n"
                },
                {
                    "date": 1709671341162,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -112,15 +112,8 @@\n     piece = Piece(GRID_WIDTH // 2, 0)\r\n     next_piece = Piece(GRID_WIDTH // 2, 0)\r\n \r\n     while not game_over:\r\n-        screen.fill(BLACK)\r\n-        piece.draw(screen)\r\n-        draw_next_piece(screen, next_piece)\r\n-        draw_grid(screen, grid)\r\n-\r\n-        pygame.display.update()\r\n-\r\n         for event in pygame.event.get():\r\n             if event.type == pygame.QUIT:\r\n                 game_over = True\r\n             if event.type == pygame.KEYDOWN:\r\n@@ -155,8 +148,14 @@\n                 next_piece = Piece(GRID_WIDTH // 2, 0)\r\n                 if piece.check_collision(grid):\r\n                     game_over = True\r\n \r\n+        screen.fill(BLACK)\r\n+        piece.draw(screen)\r\n+        draw_next_piece(screen, next_piece)\r\n+        draw_grid(screen, grid)\r\n+\r\n+        pygame.display.update()\r\n         clock.tick(5)\r\n \r\n     pygame.quit()\r\n \r\n"
                }
            ],
            "date": 1709669310026,
            "name": "Commit-0",
            "content": "import pygame\r\nimport random\r\nimport numpy as np\r\n\r\npygame.init()\r\n\r\n# Paramètres de base\r\nSCREEN_WIDTH = 300\r\nSCREEN_HEIGHT = 600\r\nBLOCK_SIZE = 30\r\nFPS = 30\r\nCOLOR_CHANGE_FREQUENCY = 1000  # changer de couleur toutes les 1000 frames\r\n\r\n# Couleurs de l'arc-en-ciel\r\nRAINBOW_COLORS = [\r\n    (255, 0, 0),     # Rouge\r\n    (255, 165, 0),   # Orange\r\n    (255, 255, 0),   # Jaune\r\n    (0, 255, 0),     # Vert\r\n    (0, 0, 255),     # Bleu\r\n    (75, 0, 130),    # Indigo\r\n    (148, 0, 211)    # Violet\r\n]\r\n\r\n# Définition des formes de Tetris avec leurs couleurs correspondantes\r\ntetris_shapes = [\r\n    [[1, 1, 1],\r\n     [0, 1, 0]],  # L\r\n    [[0, 2, 2],\r\n     [2, 2, 0]],  # S\r\n    [[3, 3, 0],\r\n     [0, 3, 3]],  # Z\r\n    [[4, 0, 0],\r\n     [4, 4, 4]],  # T\r\n    [[0, 0, 5],\r\n     [5, 5, 5]],  # J\r\n    [[6, 6, 6, 6]],  # I\r\n    [[7, 7],\r\n     [7, 7]]  # O\r\n]\r\n\r\n# Couleurs correspondantes aux formes de Tetris\r\ntetris_colors = [\r\n    (0, 0, 0),   # Noir\r\n    (255, 0, 0), # Rouge\r\n    (0, 255, 0), # Vert\r\n    (0, 0, 255), # Bleu\r\n    (255, 255, 0), # Jaune\r\n    (255, 165, 0), # Orange\r\n    (75, 0, 130),  # Indigo\r\n    (148, 0, 211)  # Violet\r\n]\r\n\r\ndef draw_matrix(matrix, offset):\r\n    for y, row in enumerate(matrix):\r\n        for x, val in enumerate(row):\r\n            if val:\r\n                pygame.draw.rect(screen, tetris_colors[val], pygame.Rect((offset[0] + x) * BLOCK_SIZE, (offset[1] + y) * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), 0)\r\n\r\ndef new_piece():\r\n    shape = random.choice(tetris_shapes)\r\n    piece = {}\r\n    piece['shape'] = shape\r\n    piece['color'] = tetris_colors[tetris_shapes.index(shape)]\r\n    piece['x'] = SCREEN_WIDTH // 2 - len(shape[0]) // 2\r\n    piece['y'] = 0\r\n    return piece\r\n\r\ndef check_collision(board, piece, offset):\r\n    off_x, off_y = offset\r\n    for y, row in enumerate(piece):\r\n        for x, val in enumerate(row):\r\n            if val:\r\n                if y + piece['y'] + off_y >= len(board) or \\\r\n                   x + piece['x'] + off_x < 0 or \\\r\n                   x + piece['x'] + off_x >= len(board[0]) or \\\r\n                   board[y + piece['y'] + off_y][x + piece['x'] + off_x]:\r\n                    return True\r\n    return False\r\n\r\ndef rotate(piece):\r\n    rotated_shape = np.rot90(piece['shape'])\r\n    return rotated_shape.tolist()\r\n\r\ndef remove_row(board, row):\r\n    del board[row]\r\n    return [[0 for _ in range(SCREEN_WIDTH // BLOCK_SIZE)]] + board, 1\r\n\r\ndef join_matrixes(board, piece, offset):\r\n    off_x, off_y = offset\r\n    for y, row in enumerate(piece):\r\n        for x, val in enumerate(row):\r\n            if val:\r\n                board[y + piece['y'] + off_y][x + piece['x'] + off_x] = val\r\n    return board\r\n\r\ndef main():\r\n    board = [[0 for _ in range(SCREEN_WIDTH // BLOCK_SIZE)] for _ in range(SCREEN_HEIGHT // BLOCK_SIZE)]\r\n\r\n    piece = new_piece()\r\n    game_over = False\r\n    score = 0\r\n    frame_count = 0\r\n    current_color_index = 0\r\n\r\n    # Initialisation de l'écran avec une couleur de l'arc-en-ciel\r\n    screen.fill(RAINBOW_COLORS[current_color_index])\r\n\r\n    while not game_over:\r\n        # Mise à jour de l'affichage de l'écran\r\n        pygame.display.update()\r\n\r\n        # Gestion des événements\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                game_over = True\r\n\r\n        # Logique du jeu ici...\r\n\r\n        # Incrémenter le compteur de frames\r\n        frame_count += 1\r\n\r\n        # Changer la couleur de l'arrière-plan toutes les COLOR_CHANGE_FREQUENCY frames\r\n        if frame_count >= COLOR_CHANGE_FREQUENCY:\r\n            frame_count = 0\r\n            current_color_index = (current_color_index + 1) % len(RAINBOW_COLORS)\r\n            screen.fill(RAINBOW_COLORS[current_color_index])\r\n\r\n    pygame.quit()\r\n\r\ndef remove_completed_lines(board):\r\n    lines_removed = 0\r\n    new_board = []\r\n    for row in range(len(board)):\r\n        if not all(board[row]):\r\n            new_board.append(board[row])\r\n        else:\r\n            lines_removed += 1\r\n    for _ in range(lines_removed):\r\n        new_board.insert(0, [0 for _ in range(SCREEN_WIDTH // BLOCK_SIZE)])\r\n    return new_board, lines_removed\r\n\r\nif _name_ == '_main_':\r\n    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))\r\n    clock = pygame.time.Clock()\r\n    main()"
        }
    ]
}